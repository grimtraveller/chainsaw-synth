/*
 * JuceProcessor.cpp
 *
 *  Created on: Nov 2, 2010
 *      Author: suva
 */

/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "JuceProcessor.h"
#include "jucegui/EditorGUI.h"

//==============================================================================
ChainsawAudioProcessor::ChainsawAudioProcessor()
	: b(32000)
{
	p.vp.stereoSpread = 0;
	p.vp.detune = 0;
	p.vp.numosc = 1;
	for(int i = 0; i < NUM_OSC_GROUPS; i++){
			p.vp.g[i].type = 0;
			p.vp.g[i].vol = 0.5;
			p.vp.g[i].octave = 0;

	}
	p.vp.volAttack = 0;
	p.vp.volDecay = 0;
	p.vp.volSustain = 1;
	p.vp.volRelease = 0;

	p.vp.filterAttack = 0;
	p.vp.filterDecay = 0;
	p.vp.filterSustain = 1;
	p.vp.filterRelease = 0;

	p.vp.filterResonance = 0;
	p.vp.filterCutoff = 1;
	p.vp.filterADSREffect = 0;

}

ChainsawAudioProcessor::~ChainsawAudioProcessor()
{
}

//==============================================================================
int ChainsawAudioProcessor::getNumParameters()
{

    return NUM_CHAINSAW_PARAMETERS;

}

float ChainsawAudioProcessor::getParameter (int index)
{
    // This method will be called by the host, probably on the audio thread, so
    // it's absolutely time-critical. Don't use critical sections or anything
    // UI-related, or anything at all that may block in any way
	switch (index){
	case STEREO_SPREAD: return p.vp.stereoSpread;
	case DETUNE: return p.vp.detune;
	case NUM_OSCILLATORS: return p.vp.numosc / 7.0f;
	case VOL_ATTACK: return p.vp.volAttack;
	case VOL_DECAY: return p.vp.volDecay;
	case VOL_SUSTAIN: return p.vp.volSustain;
	case VOL_RELEASE: return p.vp.volRelease;
	case FILTER_RESONANCE: return p.vp.filterResonance;
	case FILTER_CUTOFF: return p.vp.filterCutoff;
	case FILTER_ADSR_EFFECT: return (p.vp.filterADSREffect + 1) / 2.0f;
	case FILTER_ATTACK: return p.vp.filterAttack;
	case FILTER_DECAY: return p.vp.filterDecay;
	case FILTER_SUSTAIN: return p.vp.filterSustain;
	case FILTER_RELEASE: return p.vp.filterRelease;

	default:
		int parNum = index - OSC1_TYPE;
		int parGroup = parNum / 3;
		int parIdx = parNum % 3;
		switch(parIdx){
		case 0: return p.vp.g[parGroup].type / 3;
		case 1: return p.vp.g[parGroup].vol;
		case 2: return (p.vp.g[parGroup].octave + 5) / 10.0f;
		}
	}
	return 0;
}

void ChainsawAudioProcessor::setParameter (int index, float newValue)
{
    // This method will be called by the host, probably on the audio thread, so
    // it's absolutely time-critical. Don't use critical sections or anything
    // UI-related, or anything at all that may block in any way!
	printf("%i, %f\n", index, newValue);
	switch (index){
	case STEREO_SPREAD: p.vp.stereoSpread = newValue; return;
	case DETUNE: p.vp.detune = newValue; return;
	case NUM_OSCILLATORS: p.vp.numosc = newValue * 7; return;
	case VOL_ATTACK: p.vp.volAttack = newValue; return;
	case VOL_DECAY: p.vp.volDecay = newValue; return;
	case VOL_SUSTAIN: p.vp.volSustain = newValue; return;
	case VOL_RELEASE: p.vp.volRelease = newValue; return;
	case FILTER_RESONANCE: p.vp.filterResonance = newValue; return;
	case FILTER_CUTOFF: p.vp.filterCutoff = newValue; return;
	case FILTER_ADSR_EFFECT: p.vp.filterADSREffect = newValue * 2 - 1; return;
	case FILTER_ATTACK: p.vp.filterAttack = newValue; return;
	case FILTER_DECAY: p.vp.filterDecay = newValue; return;
	case FILTER_SUSTAIN: p.vp.filterSustain = newValue; return;
	case FILTER_RELEASE: p.vp.filterRelease = newValue; return;
	default:
		int parNum = index - OSC1_TYPE;
		int parGroup = parNum / 3;
		int parIdx = parNum % 3;
		switch(parIdx){
		case 0: p.vp.g[parGroup].type = newValue * 3; return;
		case 1: p.vp.g[parGroup].vol = newValue; return;
		case 2: p.vp.g[parGroup].octave = newValue * 10 - 5; return;
		}
	}
}

const String ChainsawAudioProcessor::getParameterName (int index)
{
	String ret;

	switch (index){
	case STEREO_SPREAD: return "Stereo spread";
	case DETUNE: return "Detune";
	case NUM_OSCILLATORS: return "Number of oscillators";
	case VOL_ATTACK: return "Volume Attack";
	case VOL_DECAY: return "Volume Decay";
	case VOL_SUSTAIN: return "Volume Sustain";
	case VOL_RELEASE: return "Volume Release";;
	case FILTER_RESONANCE: return "Filter Resonance";
	case FILTER_CUTOFF: return "Filter Cutoff";
	case FILTER_ADSR_EFFECT: return "Filter ADSR Effect";
	case FILTER_ATTACK: return "Filter Attack";
	case FILTER_DECAY: return "Filter Decay";
	case FILTER_SUSTAIN: return "Filter Sustain";
	case FILTER_RELEASE: return "Filter Release";;
	default:
		int parNum = index - OSC1_TYPE;
		int parGroup = parNum / 3;
		int parIdx = parNum % 3;
		switch(parIdx){
		case 0: ret << "OSC " << parGroup << " type"; return ret;
		case 1: ret << "OSC " << parGroup << " volume"; return ret;
		case 2: ret << "OSC " << parGroup << " octave"; return ret;
		}
	}
}

const String ChainsawAudioProcessor::getParameterText (int index)
{
    return String (getParameter (index), 2);
}

//==============================================================================
void ChainsawAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    p.sFreq = sampleRate;
    printf("Sampling frequency: %f", p.sFreq);
    keyboardState.reset();
}

void ChainsawAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    keyboardState.reset();
}

void ChainsawAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
	MidiBuffer::Iterator mbi(midiMessages);
	MidiMessage message (0, 0.0);
	int time;

    b.size = buffer.getNumSamples();
    vm.process(&b, &p);
    p.sFreq = getSampleRate();

    while(mbi.getNextEvent(message, time)) {
    	if(message.isNoteOnOrOff()){
    		Note note;
			if(message.isNoteOn()){
				note.type = Note::NOTE_ON;
			} else {
				note.type = Note::NOTE_OFF;
			}
			note.note = message.getNoteNumber();
			note.velocity = message.getVelocity();
			note.delay = time;
			vm.note(note);
    	}
    }

    for(int i = 0; i < b.size; i++) {
    	*buffer.getSampleData (0, i) += b.dataL[i];
    	*buffer.getSampleData (1, i) += b.dataR[i];
    }
}

//==============================================================================
AudioProcessorEditor* ChainsawAudioProcessor::createEditor()
{
    return new EditorGUI(this);
}

//==============================================================================
void ChainsawAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // Here's an example of how you can use XML to make it easy and more robust:

    // Create an outer XML element..
    XmlElement xml ("CHAINSAWSETTINGS");

	xml.setAttribute(T("stereoSpread"), p.vp.stereoSpread);
	xml.setAttribute(T("detune"), p.vp.detune);
	xml.setAttribute(T("numOsc"), p.vp.numosc);
	xml.setAttribute(T("volAttack"), p.vp.volAttack);
	xml.setAttribute(T("volDecay"), p.vp.volDecay);
	xml.setAttribute(T("volSustain"), p.vp.volSustain);
	xml.setAttribute(T("volRelease"), p.vp.volRelease);
	xml.setAttribute(T("filterResonance"), p.vp.filterResonance);
	xml.setAttribute(T("filterCutoff"), p.vp.filterCutoff);
	xml.setAttribute(T("filterADSREffect"), p.vp.filterADSREffect);
	xml.setAttribute(T("filterAttack"), p.vp.filterAttack);
	xml.setAttribute(T("filterDecay"), p.vp.filterDecay);
	xml.setAttribute(T("filterSustain"), p.vp.filterSustain);
	xml.setAttribute(T("filterRelease"), p.vp.filterRelease);

	for (int i = 0; i < NUM_OSC_GROUPS; i++){
		String paramName;
		paramName << "oscType" << i;
		xml.setAttribute(paramName, p.vp.g[i].type);

		paramName << "oscVolume" << i;
		xml.setAttribute(paramName, p.vp.g[i].vol);

		paramName << "oscOctave" << i;
		xml.setAttribute(paramName, p.vp.g[i].octave);
	}

    // then use this helper function to stuff it into the binary blob and return it..
    copyXmlToBinary (xml, destData);
}

void ChainsawAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.

    // This getXmlFromBinary() helper function retrieves our XML from the binary blob..
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));

    if (xmlState != 0)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName (T("CHAINSAWSETTINGS")))
        {

            // ok, now pull out our parameters..
        	p.vp.stereoSpread  = xmlState->getDoubleAttribute(T("stereoSpread"), p.vp.stereoSpread);
        	p.vp.detune = xmlState->getDoubleAttribute (T("detune"), p.vp.detune);
        	p.vp.numosc = xmlState->getIntAttribute (T("numOsc"), p.vp.numosc);
        	p.vp.volAttack = xmlState->getDoubleAttribute (T("volAttack"), p.vp.volAttack);
        	p.vp.volDecay = xmlState->getDoubleAttribute (T("volDecay"), p.vp.volDecay);
        	p.vp.volSustain = xmlState->getDoubleAttribute (T("volSustain"), p.vp.volSustain);
        	p.vp.volRelease = xmlState->getDoubleAttribute (T("volRelease"), p.vp.volRelease);
        	p.vp.filterResonance = xmlState->getDoubleAttribute (T("filterResonance"), p.vp.filterResonance);
        	p.vp.filterCutoff = xmlState->getDoubleAttribute (T("filterCutoff"), p.vp.filterCutoff);
        	p.vp.filterADSREffect = xmlState->getDoubleAttribute (T("filterADSREffect"), p.vp.filterADSREffect);
        	p.vp.filterAttack = xmlState->getDoubleAttribute (T("filterAttack"), p.vp.filterAttack);
        	p.vp.filterDecay = xmlState->getDoubleAttribute (T("filterDecay"), p.vp.filterDecay);
        	p.vp.filterSustain = xmlState->getDoubleAttribute (T("filterSustain"), p.vp.filterSustain);
        	p.vp.filterRelease = xmlState->getDoubleAttribute (T("filterRelease"), p.vp.filterRelease);

			for (int i = 0; i < NUM_OSC_GROUPS; i++){
				String paramName;
				paramName << "oscType" << i;
				p.vp.g[i].type = xmlState->getIntAttribute (paramName, p.vp.g[i].type);

				paramName << "oscVolume" << i;
				p.vp.g[i].vol = xmlState->getDoubleAttribute (paramName, p.vp.g[i].vol);

				paramName << "oscOctave" << i;
				p.vp.g[i].octave = xmlState->getIntAttribute (paramName, p.vp.g[i].octave);

			}
        }
    }
}

const String ChainsawAudioProcessor::getInputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ChainsawAudioProcessor::getOutputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ChainsawAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool ChainsawAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool ChainsawAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool ChainsawAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter(const String& commandLine)
{
    return new ChainsawAudioProcessor();
}
